{"version":3,"sources":["../../src/hooks/useForm.tsx","../../src/core/path.ts","../../src/core/store.ts"],"names":["DANGEROUS_KEYS","assertSafeKey","key","parsePath","input","s","N","out","i","start","ch","id","hasDigit","val","c","getAtPath","obj","path","parts","cur","setAtPath","value","L","curRead","leafKey","root","seg","isLast","next","nxtSeg","container","needArray","createFormStore","name","initial","devtools","base","storeImpl","createStore","creator","applyDevtools","subscribeWithSelector","updater","_replace","action","rawSet","fn","Ctx","React","useForm","opts","storeRef","store","formState","setFormState","unsub","runResolverAndApply","values","_a","_b","token","result","errors","err","Provider","children","jsxs","register","ropts","def","el","st","refs","e","now","isDirty","v","nextValLocal","prev","nextVal","dirty","cb","fromDom","p","useFormStore","ctx"],"mappings":"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","file":"useForm.js","sourcesContent":["// ------------------------------------------------------------\n// src/core/hooks.tsx\n// ------------------------------------------------------------\nimport React from 'react';\nimport type { DirtyMap, FormErrors, FormState, FormStoreApi, UseFormOptions, RegisterOptions } from '../core/types';\nimport { getAtPath, setAtPath, parsePath } from '../core/path';\nimport { createFormStore } from '../core/store';\n\nconst Ctx = React.createContext<FormStoreApi<any> | null>(null);\n\nexport function useForm<T>(opts: UseFormOptions<T>) {\n    const name = opts.name || 'rzf';\n    const storeRef = React.useRef<FormStoreApi<T>>();\n    if (!storeRef.current) {\n        storeRef.current = createFormStore<T>(name, opts.defaultValues, !!opts.devtools);\n    }\n    const store = storeRef.current!;\n\n    // local UI mirrors (optional; consumers may read store directly)\n    const [formState, setFormState] = React.useState<FormState>(store.getState().formState);\n\n    React.useEffect(() => {\n        const unsub = store.subscribe((s) => setFormState(s.formState));\n        return () => unsub();\n    }, [store]);\n\n    // --- resolver (async-safe with epoch)\n    const runResolverAndApply = React.useCallback(async (values: T) => {\n        if (!opts.resolver) return;\n        const token = ++store.getState().resolverEpoch;\n        try {\n            const result = await opts.resolver(values);\n            if (token !== store.getState().resolverEpoch) return; // outdated\n            const errors = result?.errors ?? {};\n            store.setState((s) => ({ ...s, formState: { ...s.formState, errors } }), false, { type: `${name} resolver:ok` });\n        } catch (err: any) {\n            if (token !== store.getState().resolverEpoch) return;\n            const errors: FormErrors = { _root: String(err?.message ?? err) };\n            store.setState((s) => ({ ...s, formState: { ...s.formState, errors } }), false, { type: `${name} resolver:err` });\n        }\n    }, [name, opts.resolver, store]);\n\n    // --- Provider\n    const Provider: React.FC<React.PropsWithChildren<{}>> = React.useCallback(({ children }) => {\n        return <Ctx.Provider value={store}> {children} </Ctx.Provider>;\n    }, [store]);\n\n    // --- register (supports uncontrolled)\n    function register(path: string, ropts: RegisterOptions = {}) {\n        const parts = parsePath(path);\n        const def = getAtPath(opts.defaultValues as any, parts as any);\n        if (ropts.uncontrolled) {\n            return {\n                name: path,\n                defaultValue: def as any,\n                ref: (el: HTMLInputElement | null) => {\n                    if (!el) return;\n                    const st = store.getState();\n                    const refs = st.__domRefs ?? (st.__domRefs = {});\n                    refs[path] = { current: el };\n                },\n                onChange: (e: React.ChangeEvent<HTMLInputElement>) => {\n                    const now = e.currentTarget.value;\n                    const isDirty = String(now) !== String(def ?? '');\n                    store.setState((s) => ({ ...s, formState: { ...s.formState, dirtyFields: { ...s.formState.dirtyFields, [path]: isDirty } } }), false, { type: `${name} field:dirty` });\n                },\n                onBlur: () => {\n                    store.setState((s) => ({ ...s, formState: { ...s.formState, touchedFields: { ...s.formState.touchedFields, [path]: true } } }), false, { type: `${name} field:touched` });\n                }\n            } as const;\n        }\n        // controlled (minimal): bind through store.value (not fully featured; MVP)\n        return {\n            name: path,\n            value: getAtPath((store.getState() as any).value ?? (opts.defaultValues as any), parts as any) ?? '',\n            onChange: (e: React.ChangeEvent<HTMLInputElement>) => {\n                const v = e.currentTarget.value;\n                let nextValLocal: any;\n                store.setState((s) => {\n                    const prev = (s as any).value ?? (opts.defaultValues as any);\n                    const nextVal = setAtPath(prev, parts as any, v);\n                    nextValLocal = nextVal; // capture for resolver\n                    const dirty: DirtyMap = {\n                        ...s.formState.dirtyFields,\n                        [path]: String(v) !== String(def ?? ''),\n                    };\n                    return { ...s, value: nextVal, formState: { ...s.formState, dirtyFields: dirty } } as any;\n                }, false, { type: `${name} field:set` });\n\n                // Schedule resolver in a microtask to avoid reentrancy and to play nice with tests\n                const enqueue = (cb: () => void) =>\n                    typeof queueMicrotask === 'function'\n                        ? queueMicrotask(cb)\n                        : Promise.resolve().then(cb);\n                enqueue(() => runResolverAndApply(nextValLocal as T));\n            },\n            onBlur: () => {\n                store.setState((s) => ({ ...s, formState: { ...s.formState, touchedFields: { ...s.formState.touchedFields, [path]: true } } }), false, { type: `${name} field:touched` });\n            }\n        } as const;\n    }\n\n    // --- handleSubmit (collects uncontrolled via refs; controlled via state)\n    const handleSubmit = (fn: (values: T) => void) => (e?: React.FormEvent) => {\n        e?.preventDefault?.();\n        // Uncontrolled: read from DOM\n        const st = store.getState();\n        const refs = st.__domRefs ?? {};\n        const fromDom: any = JSON.parse(JSON.stringify(opts.defaultValues));\n        Object.keys(refs).forEach((p) => {\n            const el = refs[p]?.current; if (!el) return;\n            // best-effort: write string value\n            const parts = parsePath(p);\n            const prev = getAtPath(fromDom, parts);\n            const v = el.value;\n            const next = setAtPath(fromDom, parts, v);\n            Object.assign(fromDom, next);\n        });\n        fn(fromDom);\n    };\n\n    return { Provider, register, handleSubmit, formState, store } as const;\n}\n\nexport function useFormStore<T>() {\n    const ctx = React.useContext(Ctx);\n    if (!ctx) throw new Error('useFormStore must be used under Provider');\n    return ctx as FormStoreApi<T>;\n}\n\n\n\n","/**\n * Path utilities: parse, get and set by dot/bracket paths.\n *\n * Examples of accepted paths:\n *  - \"user.email\"\n *  - \"rows.abc[0].score\"\n *  - [\"rows\", \"abc\", 0, \"score\"]\n */\n// ------------------------------------------------------------\n// src/core/path.ts\n// ------------------------------------------------------------\nimport type { PathLike, PathSeg } from './types';\n\n/**\n * Guard list to prevent prototype-pollution via unsafe keys.\n * Any path segment equal to one of these will throw.\n */\nconst DANGEROUS_KEYS = new Set(['__proto__', 'prototype', 'constructor']);\n\n/**\n * Throws if a key is unsafe. Used for string segments only.\n * @param key Key to check.\n * @throws Error when an unsafe key is found.\n */\nfunction assertSafeKey(key: string) {\n    if (DANGEROUS_KEYS.has(key)) throw new Error(`Unsafe key: ${key}`);\n}\n\n/**\n * Parses a dot/bracket path into an array of segments.\n *\n * Fast path: returns a shallow copy if the input is already an array.\n * Identifiers are split by dots. Numeric indices are read from bracket pairs: `[123]`.\n * Only digits are allowed inside brackets.\n *\n * @param input Path as a dot/bracket string or an array of segments.\n * @returns Array of segments (`string` and `number`).\n * @throws Error for invalid indices, unclosed brackets, or unsafe keys.\n */\nexport function parsePath(input: PathLike): PathSeg[] {\n    // Fast path: if input is already array-like, return a shallow copy to avoid aliasing.\n    if (Array.isArray(input)) return (input as unknown as PathSeg[]).slice();\n\n    const s = String(input);\n    const N = s.length;\n    if (N === 0) return [];\n\n    const out: PathSeg[] = [];\n    let i = 0;\n\n    while (i < N) {\n        // read identifier (up to '.' or '[')\n        let start = i;\n        while (i < N) {\n            const ch = s.charCodeAt(i);\n            // '.'(46) '['(91)\n            if (ch === 46 || ch === 91) break;\n            i++;\n        }\n        if (i > start) {\n            const id = s.slice(start, i);\n            assertSafeKey(id);\n            out.push(id);\n        }\n        if (i >= N) break;\n\n        const ch = s.charCodeAt(i);\n        if (ch === 46 /* '.' */) { i++; continue; }\n\n        if (ch === 91 /* '[' */) {\n            i++; // skip '['\n            // manual integer parse: only digits allowed\n            let hasDigit = false;\n            let val = 0;\n            while (i < N) {\n                const c = s.charCodeAt(i);\n                if (c === 93 /* ']' */) break;\n                // '0'(48) .. '9'(57)\n                if (c < 48 || c > 57) throw new Error(`Invalid index: ${s[i]}`);\n                hasDigit = true;\n                val = val * 10 + (c - 48);\n                i++;\n            }\n            if (i >= N || s.charCodeAt(i) !== 93 /* ']' */) throw new Error('Unclosed bracket');\n            i++; // skip ']'\n            if (!hasDigit) throw new Error('Invalid index: ');\n            out.push(val);\n            // optional '.' after bracket\n            if (i < N && s.charCodeAt(i) === 46 /* '.' */) i++;\n        }\n    }\n    return out;\n}\n\n/**\n * Reads a value from an object by path.\n *\n * Walks the object using the parsed segments. Returns `undefined` if any parent is `null`/`undefined`.\n *\n * @template T Expected value type.\n * @param obj   Root object to read.\n * @param path  Path in string or array form.\n * @returns     The value at the leaf, or `undefined` if missing.\n */\nexport function getAtPath<T = any>(obj: any, path: PathLike): T | undefined {\n    const parts = parsePath(path);\n    let cur = obj;\n    for (let i = 0; i < parts.length; i++) {\n        if (cur == null) return undefined;\n        // Using bracket access to support both string and numeric segments.\n        cur = cur[parts[i] as any];\n    }\n    return cur as T;\n}\n\n/**\n * Writes a value to an object by path, returning a new root.\n *\n * Creates shallow copies along the path only. Other branches are kept by reference.\n * If the existing leaf is strictly equal to the new value, returns the original root (no-op).\n *\n * @template T   Expected root type after the write.\n * @param obj    Root object or array. May be `undefined`/`null`.\n * @param path   Path in string or array form.\n * @param value  New leaf value.\n * @returns      New root with the path updated.\n */\nexport function setAtPath<T extends object = any>(obj: any, path: PathLike, value: any): T {\n    const parts = parsePath(path);\n    const L = parts.length;\n    if (L === 0) return value as T;\n\n    // --- Fast no-op: read current leaf value first without cloning ---\n    let curRead: any = obj;\n    for (let i = 0; i < L - 1; i++) {\n        if (curRead == null) break;\n        curRead = curRead[parts[i] as any];\n    }\n    const leafKey = parts[L - 1] as any;\n    const oldLeaf = curRead != null ? curRead[leafKey] : undefined;\n    if (oldLeaf === value) return obj as T;\n\n    // --- Write path with shallow copies only along the path ---\n    const rootIsArray = Array.isArray(obj);\n    const root: any = rootIsArray ? (obj ? obj.slice() : []) : (obj ? { ...obj } : {});\n    let cur: any = root;\n\n    for (let i = 0; i < L; i++) {\n        const seg = parts[i] as any;\n        const isLast = i === L - 1;\n\n        // Defensive key check for string segments only\n        if (typeof seg === 'string') assertSafeKey(seg);\n\n        if (isLast) {\n            cur[seg] = value;\n            break;\n        }\n\n        const next = cur[seg];\n        const nxtSeg = parts[i + 1];\n\n        // Materialize the next container with minimal branching and shallow copy when needed\n        let container: any;\n        const needArray = typeof nxtSeg === 'number';\n        if (Array.isArray(next)) {\n            // Preserve array identity semantics with a shallow copy\n            container = next.slice();\n        } else if (needArray) {\n            container = [];\n        } else {\n            // object branch\n            container = next ? { ...next } : {};\n        }\n\n        cur[seg] = container;\n        cur = container;\n    }\n\n    return root;\n}\n","/**\n * Form store factory and micro-batcher.\n *\n * The store is a vanilla Zustand instance (no React import).\n * The batcher coalesces keyed payloads into microtasks.\n */\n\n// ------------------------------------------------------------\n// src/core/store.ts\n// ------------------------------------------------------------\nimport { createStore } from 'zustand/vanilla';\nimport { subscribeWithSelector } from 'zustand/middleware';\nimport type { FormStoreApi, FormStoreState, FormState } from './types';\n\n/** Public shape of the batcher returned by {@link createBatcher}. */\nexport type Batcher<TKey extends string = string, TPayload = unknown> = ReturnType<typeof createBatcher<TKey, TPayload>>;\n\n/**\n * Creates a micro-batcher for keyed payloads.\n *\n * Last write wins per key within the same microtask. Insertion order is kept.\n * Optional `max` evicts the oldest entries when full. Use `max <= 0` to keep\n * only the most recent entry (size never exceeds 1).\n * If `useTransition` is true and `startTransition` exists, the flush runs in a transition.\n *\n * @param cfg Optional config. `{ max?: number; useTransition?: boolean }`.\n * @returns An object with a single `push(key, payload, flush)` method.\n */\nexport function createBatcher<TKey extends string = string, TPayload = unknown>(cfg: { max?: number; useTransition?: boolean } = {}) {\n    const max = cfg.max ?? 1000;\n    const canTrans = !!cfg.useTransition && typeof (globalThis as any).startTransition === 'function';\n    const startTrans: ((fn: () => void) => void) | null = canTrans ? (globalThis as any).startTransition : null;\n\n    // Maintain insertion order and last-write-wins payloads\n    const q = new Map<TKey, TPayload>();\n    let scheduled = false;\n    let batchFlush: ((k: TKey, p: TPayload) => void) | null = null;\n\n    // Reentrancy: pushes during flush schedule the next microtask (not this batch).\n    const flushNow = () => {\n        scheduled = false;\n        const fn = batchFlush;\n        const run = () => {\n            try {\n                if (fn) {\n                    q.forEach((p, k) => {\n                        try { fn(k, p); } catch { /* keep batch alive */ }\n                    });\n                }\n            } finally {\n                q.clear();\n                batchFlush = null;\n            }\n        };\n        if (startTrans) startTrans(run); else run();\n    };\n\n    const schedule = () => {\n        if (scheduled) return;\n        scheduled = true;\n        queueMicrotask(flushNow);\n    };\n\n    // Eviction policy:\n    // - limit <= 0  => keep only the most recent entry (size stays <= 1)\n    // - limit > 0   => cap at `limit`, evicting the oldest on insert when full.\n    const evictOldest = (limit: number) => {\n        if (limit <= 0) {\n            // Keep only the most recent entry: always drop oldest before inserting.\n            const it = q.keys().next();\n            if (!it.done) q.delete(it.value);\n            return;\n        }\n        if (q.size >= limit) {\n            const it = q.keys().next();\n            if (!it.done) q.delete(it.value);\n        }\n    };\n\n    return {\n        push(key: TKey, payload: TPayload, flush: (k: TKey, p: TPayload) => void) {\n            // Pin the flusher for this batch to the first push that schedules it.\n            // Later pushes in the same batch do not override the flusher.\n            if (!scheduled) batchFlush = flush;\n\n            // Insert or update payload (keeps original insertion order)\n            if (!q.has(key)) {\n                evictOldest(max);\n            }\n            q.set(key, payload);\n\n            schedule();\n        }\n    };\n}\n\n/**\n * Creates a vanilla Zustand store for one form instance.\n *\n * No React dependency. DevTools can be enabled in development.\n * The store exposes a small API compatible with the rest of the library.\n *\n * @template T Shape of the form values.\n * @param name     Debug name for DevTools.\n * @param initial  Initial values object.\n * @param devtools Enable Redux DevTools integration in development builds.\n * @returns        A `FormStoreApi<T>` facade.\n */\nexport function createFormStore<T>(name: string, initial: T, devtools: boolean): FormStoreApi<T> {\n    const base: FormStoreState<T> = {\n        name: name || 'rzf',\n        __initial: initial,\n        formState: { dirtyFields: {}, touchedFields: {}, errors: {} },\n        resolverEpoch: 0,\n    };\n\n    const withMw = (creator: any) => {\n        if (process.env.NODE_ENV !== 'production' && devtools) {\n            // eslint-disable-next-line @typescript-eslint/no-var-requires\n            const { devtools: applyDevtools } = require('zustand/middleware'); // Use require here to avoid ESM/CJS top-level interop issues.\n            return applyDevtools(subscribeWithSelector(creator), { name });\n        }\n        return subscribeWithSelector(creator);\n    };\n    // Create a vanilla Zustand store. No React dependency here.\n    const storeImpl = createStore<FormStoreState<T>>(withMw(() => base));\n\n    return {\n        getState: storeImpl.getState,\n        setState: (updater, _replace, action) => {\n            const next = updater(storeImpl.getState());\n            const rawSet: unknown = (storeImpl as unknown as { setState: (...args: unknown[]) => void }).setState;\n            // Call signatures vary depending on middleware; detect arity.\n            if (typeof rawSet === 'function' && (rawSet as Function).length >= 3 && action !== undefined) {\n                (rawSet as (partial: unknown, replace?: boolean, action?: unknown) => void)(next as unknown, true, action);\n            } else if (typeof rawSet === 'function') {\n                (rawSet as (partial: unknown, replace?: boolean) => void)(next as unknown, true);\n            }\n        },\n        subscribe: (fn) => storeImpl.subscribe(fn),\n    };\n}"]}