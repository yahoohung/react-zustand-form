{"version":3,"sources":["../src/core/path.ts","../src/core/store.ts","../src/core/hooks.tsx"],"names":["ch"],"mappings":";;;;;;;AAKA,IAAM,iCAAiB,IAAI,GAAA,CAAI,CAAC,WAAA,EAAa,WAAA,EAAa,aAAa,CAAC,CAAA;AAExE,SAAS,cAAc,CAAA,EAAW;AAC9B,EAAA,IAAI,cAAA,CAAe,IAAI,CAAC,CAAA,QAAS,IAAI,KAAA,CAAM,CAAA,YAAA,EAAe,CAAC,CAAA,CAAE,CAAA;AACjE;AAEO,SAAS,UAAU,KAAA,EAA4B;AAClD,EAAA,IAAI,MAAM,OAAA,CAAQ,KAAK,GAAG,OAAO,KAAA,CAAM,KAAK,KAA+B,CAAA;AAC3E,EAAA,MAAM,CAAA,GAAI,OAAO,KAAK,CAAA;AACtB,EAAA,IAAI,CAAC,CAAA,EAAG,OAAO,EAAC;AAChB,EAAA,MAAM,MAAiB,EAAC;AACxB,EAAA,IAAI,CAAA,GAAI,CAAA;AACR,EAAA,MAAM,IAAI,CAAA,CAAE,MAAA;AACZ,EAAA,OAAO,IAAI,CAAA,EAAG;AAEV,IAAA,IAAI,EAAA,GAAK,EAAA;AACT,IAAA,OAAO,IAAI,CAAA,EAAG;AACV,MAAA,MAAMA,GAAAA,GAAK,EAAE,CAAC,CAAA;AACd,MAAA,IAAIA,GAAAA,KAAO,GAAA,IAAOA,GAAAA,KAAO,GAAA,EAAK;AAC9B,MAAA,EAAA,IAAMA,GAAAA;AAAI,MAAA,CAAA,EAAA;AAAA,IACd;AACA,IAAA,IAAI,EAAA,EAAI;AACJ,MAAA,aAAA,CAAc,EAAE,CAAA;AAChB,MAAA,GAAA,CAAI,KAAK,EAAE,CAAA;AAAA,IACf;AACA,IAAA,IAAI,KAAK,CAAA,EAAG;AACZ,IAAA,MAAM,EAAA,GAAK,EAAE,CAAC,CAAA;AACd,IAAA,IAAI,OAAO,GAAA,EAAK;AAAE,MAAA,CAAA,EAAA;AAAK,MAAA;AAAA,IAAU;AACjC,IAAA,IAAI,OAAO,GAAA,EAAK;AAEZ,MAAA,CAAA,EAAA;AACA,MAAA,IAAI,GAAA,GAAM,EAAA;AACV,MAAA,OAAO,CAAA,GAAI,CAAA,IAAK,CAAA,CAAE,CAAC,MAAM,GAAA,EAAK;AAAE,QAAA,GAAA,IAAO,EAAE,CAAA,EAAG,CAAA;AAAA,MAAG;AAC/C,MAAA,IAAI,CAAA,IAAK,CAAA,EAAG,MAAM,IAAI,MAAM,kBAAkB,CAAA;AAC9C,MAAA,CAAA,EAAA;AACA,MAAA,IAAI,CAAC,OAAA,CAAQ,IAAA,CAAK,GAAG,CAAA,QAAS,IAAI,KAAA,CAAM,CAAA,eAAA,EAAkB,GAAG,CAAA,CAAE,CAAA;AAC/D,MAAA,MAAM,GAAA,GAAM,OAAO,GAAG,CAAA;AACtB,MAAA,IAAI,GAAA,GAAM,CAAA,IAAK,CAAC,MAAA,CAAO,SAAA,CAAU,GAAG,CAAA,EAAG,MAAM,IAAI,KAAA,CAAM,CAAA,eAAA,EAAkB,GAAG,CAAA,CAAE,CAAA;AAC9E,MAAA,GAAA,CAAI,KAAK,GAAG,CAAA;AACZ,MAAA,IAAI,CAAA,GAAI,CAAA,IAAK,CAAA,CAAE,CAAC,MAAM,GAAA,EAAK,CAAA,EAAA;AAAA,IAC/B;AAAA,EACJ;AACA,EAAA,OAAO,GAAA;AACX;AAEO,SAAS,SAAA,CAAmB,KAAU,IAAA,EAA+B;AACxE,EAAA,MAAM,KAAA,GAAQ,UAAU,IAAI,CAAA;AAC5B,EAAA,IAAI,GAAA,GAAM,GAAA;AACV,EAAA,KAAA,MAAW,KAAK,KAAA,EAAO;AACnB,IAAA,IAAI,GAAA,IAAO,MAAM,OAAO,MAAA;AACxB,IAAA,GAAA,GAAM,IAAI,CAAQ,CAAA;AAAA,EACtB;AACA,EAAA,OAAO,GAAA;AACX;AAEO,SAAS,SAAA,CAAkC,GAAA,EAAU,IAAA,EAAgB,KAAA,EAAe;AACvF,EAAA,MAAM,KAAA,GAAQ,UAAU,IAAI,CAAA;AAC5B,EAAA,IAAI,KAAA,CAAM,MAAA,KAAW,CAAA,EAAG,OAAO,KAAA;AAC/B,EAAA,MAAM,WAAA,GAAc,KAAA,CAAM,OAAA,CAAQ,GAAG,CAAA;AACrC,EAAA,MAAM,IAAA,GAAY,cAAc,GAAA,CAAI,KAAA,KAAU,EAAE,GAAI,GAAA,IAAO,EAAC,EAAG;AAC/D,EAAA,IAAI,GAAA,GAAW,IAAA;AACf,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACnC,IAAA,MAAM,GAAA,GAAM,MAAM,CAAC,CAAA;AACnB,IAAA,MAAM,MAAA,GAAS,CAAA,KAAM,KAAA,CAAM,MAAA,GAAS,CAAA;AACpC,IAAA,IAAI,OAAO,QAAQ,QAAA,EAAU;AACzB,MAAA,MAAM,IAAA,GAAO,IAAI,GAAG,CAAA;AACpB,MAAA,IAAI,MAAA,EAAQ;AACR,QAAA,GAAA,CAAI,GAAG,CAAA,GAAI,KAAA;AAAA,MACf,CAAA,MAAO;AACH,QAAA,MAAM,MAAA,GAAS,KAAA,CAAM,CAAA,GAAI,CAAC,CAAA;AAC1B,QAAA,MAAM,SAAA,GAAY,MAAM,OAAA,CAAQ,IAAI,KAAK,OAAO,MAAA,KAAW,WAAY,KAAA,CAAM,OAAA,CAAQ,IAAI,CAAA,GAAI,IAAA,CAAK,OAAM,GAAI,KAAO,EAAE,GAAI,IAAA,IAAQ,EAAC,EAAG;AACrI,QAAA,GAAA,CAAI,GAAG,CAAA,GAAI,SAAA;AACX,QAAA,GAAA,GAAM,SAAA;AAAA,MACV;AAAA,IACJ,CAAA,MAAO;AACH,MAAA,aAAA,CAAc,GAAG,CAAA;AACjB,MAAA,MAAM,IAAA,GAAO,IAAI,GAAG,CAAA;AACpB,MAAA,IAAI,MAAA,EAAQ;AACR,QAAA,GAAA,CAAI,GAAG,CAAA,GAAI,KAAA;AAAA,MACf,CAAA,MAAO;AACH,QAAA,MAAM,MAAA,GAAS,KAAA,CAAM,CAAA,GAAI,CAAC,CAAA;AAC1B,QAAA,MAAM,SAAA,GAAY,MAAM,OAAA,CAAQ,IAAI,KAAK,OAAO,MAAA,KAAW,WAAY,KAAA,CAAM,OAAA,CAAQ,IAAI,CAAA,GAAI,IAAA,CAAK,OAAM,GAAI,KAAO,EAAE,GAAI,IAAA,IAAQ,EAAC,EAAG;AACrI,QAAA,GAAA,CAAI,GAAG,CAAA,GAAI,SAAA;AACX,QAAA,GAAA,GAAM,SAAA;AAAA,MACV;AAAA,IACJ;AAAA,EACJ;AACA,EAAA,OAAO,IAAA;AACX;ACpFO,SAAS,aAAA,CAAc,GAAA,GAAiD,EAAC,EAAG;AAC/E,EAAA,MAAM,GAAA,GAAM,IAAI,GAAA,IAAO,GAAA;AACvB,EAAA,MAAM,QAAA,GAAW,CAAC,CAAC,GAAA,CAAI,aAAA;AACvB,EAAA,IAAI,IAAyB,EAAC;AAC9B,EAAA,IAAI,QAAkB,EAAC;AACvB,EAAA,IAAI,SAAA,GAAY,KAAA;AAChB,EAAA,MAAM,QAAA,GAAW,CAAC,GAAA,KAAoB;AAClC,IAAA,IAAI,SAAA,EAAW;AAAQ,IAAA,SAAA,GAAY,IAAA;AACnC,IAAA,cAAA,CAAe,MAAM;AACjB,MAAA,SAAA,GAAY,KAAA;AACZ,MAAA,IAAI,QAAA,IAAY,OAAQ,UAAA,CAAmB,eAAA,KAAoB,UAAA,EAAY;AACvE,QAAC,UAAA,CAAmB,gBAAgB,GAAG,CAAA;AAAA,MAC3C,OAAO,GAAA,EAAI;AAAA,IACf,CAAC,CAAA;AAAA,EACL,CAAA;AACA,EAAA,OAAO;AAAA,IACH,IAAA,CAAK,GAAA,EAAa,OAAA,EAAc,KAAA,EAAoC;AAChE,MAAA,IAAI,EAAE,GAAA,IAAO,CAAA,CAAA,EAAI,KAAA,CAAM,KAAK,GAAG,CAAA;AAC/B,MAAA,CAAA,CAAE,GAAG,CAAA,GAAI,OAAA;AACT,MAAA,IAAI,KAAA,CAAM,MAAA,GAAS,GAAA,EAAK,KAAA,CAAM,KAAA,EAAM;AACpC,MAAA,QAAA,CAAS,MAAM;AACX,QAAA,MAAM,IAAA,GAAO,KAAA;AAAO,QAAA,KAAA,GAAQ,EAAC;AAC7B,QAAA,MAAM,QAAA,GAAW,CAAA;AAAG,QAAA,CAAA,GAAI,EAAC;AACzB,QAAA,KAAA,MAAW,KAAK,IAAA,EAAM,KAAA,CAAM,CAAA,EAAG,QAAA,CAAS,CAAC,CAAC,CAAA;AAAA,MAC9C,CAAC,CAAA;AAAA,IACL;AAAA,GACJ;AACJ;AAEO,SAAS,eAAA,CAAmB,IAAA,EAAc,OAAA,EAAY,QAAA,EAAoC;AAC7F,EAAA,MAAM,IAAA,GAA0B;AAAA,IAC5B,MAAM,IAAA,IAAQ,KAAA;AAAA,IACd,SAAA,EAAW,OAAA;AAAA,IACX,SAAA,EAAW,EAAE,WAAA,EAAa,EAAC,EAAG,eAAe,EAAC,EAAG,MAAA,EAAQ,EAAC,EAAE;AAAA,IAC5D,aAAA,EAAe;AAAA,GACnB;AAEA,EAAA,MAAM,MAAA,GAAS,CAAC,OAAA,KACX,OAAA,CAAQ,IAAI,QAAA,KAAa,YAAA,IAAgB,WACnC,SAAA,CAAQ,oBAAoB,EAAE,QAAA,CAAiB,qBAAA,CAAsB,OAAO,CAAA,EAAG,EAAE,MAAM,CAAA,GACxF,sBAAsB,OAAO,CAAA;AAIvC,EAAA,MAAM,SAAA,GAAY,WAAA,CAA+B,MAAA,CAAO,MAAM,IAAI,CAAC,CAAA;AAEnE,EAAA,OAAO;AAAA,IACH,UAAU,SAAA,CAAU,QAAA;AAAA,IACpB,QAAA,EAAU,CAAC,OAAA,EAAS,QAAA,EAAU,MAAA,KAAW;AACrC,MAAA,MAAM,IAAA,GAAO,OAAA,CAAQ,SAAA,CAAU,QAAA,EAAU,CAAA;AAEzC,MAAA,SAAA,CAAU,QAAA,CAAS,MAAa,IAAI,CAAA;AACpC,MAAA,IAAK,SAAA,CAAkB,QAAA,CAAS,MAAA,IAAU,CAAA,IAAK,MAAA,EAAQ;AAEnD,QAAC,SAAA,CAAkB,QAAA,CAAS,IAAA,EAAa,IAAA,EAAM,MAAM,CAAA;AAAA,MACzD;AAAA,IACJ,CAAA;AAAA,IACA,SAAA,EAAW,CAAC,EAAA,KAAO,SAAA,CAAU,UAAU,EAAE;AAAA,GAC7C;AACJ;AC5DA,IAAM,GAAA,GAAM,KAAA,CAAM,aAAA,CAAwC,IAAI,CAAA;AAEvD,SAAS,QAAW,IAAA,EAAyB;AAChD,EAAA,MAAM,IAAA,GAAO,KAAK,IAAA,IAAQ,KAAA;AAC1B,EAAA,MAAM,QAAA,GAAW,MAAM,MAAA,EAAwB;AAC/C,EAAA,IAAI,CAAC,SAAS,OAAA,EAAS;AACnB,IAAA,QAAA,CAAS,OAAA,GAAU,gBAAmB,IAAA,EAAM,IAAA,CAAK,eAAe,CAAC,CAAC,KAAK,QAAQ,CAAA;AAAA,EACnF;AACA,EAAA,MAAM,QAAQ,QAAA,CAAS,OAAA;AAGvB,EAAA,MAAM,CAAC,WAAW,YAAY,CAAA,GAAI,MAAM,QAAA,CAAoB,KAAA,CAAM,QAAA,EAAS,CAAE,SAAS,CAAA;AAEtF,EAAA,KAAA,CAAM,UAAU,MAAM;AAClB,IAAA,MAAM,KAAA,GAAQ,MAAM,SAAA,CAAU,CAAC,MAAM,YAAA,CAAa,CAAA,CAAE,SAAS,CAAC,CAAA;AAC9D,IAAA,OAAO,MAAM,KAAA,EAAM;AAAA,EACvB,CAAA,EAAG,CAAC,KAAK,CAAC,CAAA;AAGV,EAAA,MAAM,mBAAA,GAAsB,KAAA,CAAM,WAAA,CAAY,OAAO,MAAA,KAAc;AAC/D,IAAA,IAAI,CAAC,KAAK,QAAA,EAAU;AACpB,IAAA,MAAM,KAAA,GAAQ,EAAE,KAAA,CAAM,QAAA,EAAS,CAAE,aAAA;AACjC,IAAA,IAAI;AACA,MAAA,MAAM,MAAA,GAAS,MAAM,IAAA,CAAK,QAAA,CAAS,MAAM,CAAA;AACzC,MAAA,IAAI,KAAA,KAAU,KAAA,CAAM,QAAA,EAAS,CAAE,aAAA,EAAe;AAC9C,MAAA,MAAM,MAAA,GAAS,MAAA,EAAQ,MAAA,IAAU,EAAC;AAClC,MAAA,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA,MAAO,EAAE,GAAG,CAAA,EAAG,SAAA,EAAW,EAAE,GAAG,CAAA,CAAE,WAAW,MAAA,EAAO,KAAM,KAAA,EAAO,EAAE,MAAM,CAAA,EAAG,IAAI,gBAAgB,CAAA;AAAA,IACnH,SAAS,GAAA,EAAU;AACf,MAAA,IAAI,KAAA,KAAU,KAAA,CAAM,QAAA,EAAS,CAAE,aAAA,EAAe;AAC9C,MAAA,MAAM,SAAqB,EAAE,KAAA,EAAO,OAAO,GAAA,EAAK,OAAA,IAAW,GAAG,CAAA,EAAE;AAChE,MAAA,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA,MAAO,EAAE,GAAG,CAAA,EAAG,SAAA,EAAW,EAAE,GAAG,CAAA,CAAE,WAAW,MAAA,EAAO,KAAM,KAAA,EAAO,EAAE,MAAM,CAAA,EAAG,IAAI,iBAAiB,CAAA;AAAA,IACpH;AAAA,EACJ,GAAG,CAAC,IAAA,EAAM,IAAA,CAAK,QAAA,EAAU,KAAK,CAAC,CAAA;AAG/B,EAAA,MAAM,WAAkD,KAAA,CAAM,WAAA,CAAY,CAAC,EAAE,UAAS,KAAM;AACxF,IAAA,uBAAO,IAAA,CAAC,GAAA,CAAI,QAAA,EAAJ,EAAa,OAAO,KAAA,EAAO,QAAA,EAAA;AAAA,MAAA,GAAA;AAAA,MAAE,QAAA;AAAA,MAAS;AAAA,KAAA,EAAC,CAAA;AAAA,EACnD,CAAA,EAAG,CAAC,KAAK,CAAC,CAAA;AAGV,EAAA,SAAS,QAAA,CAAS,IAAA,EAAc,KAAA,GAAyB,EAAC,EAAG;AACzD,IAAA,MAAM,KAAA,GAAQ,UAAU,IAAI,CAAA;AAC5B,IAAA,MAAM,GAAA,GAAM,SAAA,CAAU,IAAA,CAAK,aAAA,EAAsB,KAAY,CAAA;AAC7D,IAAA,IAAI,MAAM,YAAA,EAAc;AACpB,MAAA,OAAO;AAAA,QACH,IAAA,EAAM,IAAA;AAAA,QACN,YAAA,EAAc,GAAA;AAAA,QACd,GAAA,EAAK,CAAC,EAAA,KAAgC;AAClC,UAAA,IAAI,CAAC,EAAA,EAAI;AACT,UAAA,MAAM,EAAA,GAAK,MAAM,QAAA,EAAS;AAC1B,UAAA,MAAM,IAAA,GAAO,EAAA,CAAG,SAAA,KAAc,EAAA,CAAG,YAAY,EAAC,CAAA;AAC9C,UAAA,IAAA,CAAK,IAAI,CAAA,GAAI,EAAE,OAAA,EAAS,EAAA,EAAG;AAAA,QAC/B,CAAA;AAAA,QACA,QAAA,EAAU,CAAC,CAAA,KAA2C;AAClD,UAAA,MAAM,GAAA,GAAM,EAAE,aAAA,CAAc,KAAA;AAC5B,UAAA,MAAM,UAAU,MAAA,CAAO,GAAG,CAAA,KAAM,MAAA,CAAO,OAAO,EAAE,CAAA;AAChD,UAAA,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA,MAAO,EAAE,GAAG,CAAA,EAAG,SAAA,EAAW,EAAE,GAAG,CAAA,CAAE,SAAA,EAAW,WAAA,EAAa,EAAE,GAAG,CAAA,CAAE,SAAA,CAAU,WAAA,EAAa,CAAC,IAAI,GAAG,OAAA,EAAQ,EAAE,EAAE,CAAA,EAAI,KAAA,EAAO,EAAE,IAAA,EAAM,CAAA,EAAG,IAAI,gBAAgB,CAAA;AAAA,QACzK,CAAA;AAAA,QACA,QAAQ,MAAM;AACV,UAAA,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA,MAAO,EAAE,GAAG,CAAA,EAAG,SAAA,EAAW,EAAE,GAAG,CAAA,CAAE,SAAA,EAAW,aAAA,EAAe,EAAE,GAAG,CAAA,CAAE,SAAA,CAAU,aAAA,EAAe,CAAC,IAAI,GAAG,IAAA,EAAK,EAAE,EAAE,CAAA,EAAI,KAAA,EAAO,EAAE,IAAA,EAAM,CAAA,EAAG,IAAI,kBAAkB,CAAA;AAAA,QAC5K;AAAA,OACJ;AAAA,IACJ;AAEA,IAAA,OAAO;AAAA,MACH,IAAA,EAAM,IAAA;AAAA,MACN,KAAA,EAAO,UAAW,KAAA,CAAM,QAAA,GAAmB,KAAA,IAAU,IAAA,CAAK,aAAA,EAAuB,KAAY,CAAA,IAAK,EAAA;AAAA,MAClG,QAAA,EAAU,CAAC,CAAA,KAA2C;AAClD,QAAA,MAAM,CAAA,GAAI,EAAE,aAAA,CAAc,KAAA;AAC1B,QAAA,IAAI,YAAA;AACJ,QAAA,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA,KAAM;AAClB,UAAA,MAAM,IAAA,GAAQ,CAAA,CAAU,KAAA,IAAU,IAAA,CAAK,aAAA;AACvC,UAAA,MAAM,OAAA,GAAU,SAAA,CAAU,IAAA,EAAM,KAAA,EAAc,CAAC,CAAA;AAC/C,UAAA,YAAA,GAAe,OAAA;AACf,UAAA,MAAM,KAAA,GAAkB;AAAA,YACpB,GAAG,EAAE,SAAA,CAAU,WAAA;AAAA,YACf,CAAC,IAAI,GAAG,MAAA,CAAO,CAAC,CAAA,KAAM,MAAA,CAAO,OAAO,EAAE;AAAA,WAC1C;AACA,UAAA,OAAO,EAAE,GAAG,CAAA,EAAG,KAAA,EAAO,OAAA,EAAS,SAAA,EAAW,EAAE,GAAG,CAAA,CAAE,SAAA,EAAW,WAAA,EAAa,KAAA,EAAM,EAAE;AAAA,QACrF,GAAG,KAAA,EAAO,EAAE,MAAM,CAAA,EAAG,IAAI,cAAc,CAAA;AAGvC,QAAA,MAAM,OAAA,GAAU,CAAC,EAAA,KACb,OAAO,cAAA,KAAmB,UAAA,GACpB,cAAA,CAAe,EAAE,CAAA,GACjB,OAAA,CAAQ,OAAA,EAAQ,CAAE,KAAK,EAAE,CAAA;AACnC,QAAA,OAAA,CAAQ,MAAM,mBAAA,CAAoB,YAAiB,CAAC,CAAA;AAAA,MACxD,CAAA;AAAA,MACA,QAAQ,MAAM;AACV,QAAA,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA,MAAO,EAAE,GAAG,CAAA,EAAG,SAAA,EAAW,EAAE,GAAG,CAAA,CAAE,SAAA,EAAW,aAAA,EAAe,EAAE,GAAG,CAAA,CAAE,SAAA,CAAU,aAAA,EAAe,CAAC,IAAI,GAAG,IAAA,EAAK,EAAE,EAAE,CAAA,EAAI,KAAA,EAAO,EAAE,IAAA,EAAM,CAAA,EAAG,IAAI,kBAAkB,CAAA;AAAA,MAC5K;AAAA,KACJ;AAAA,EACJ;AAGA,EAAA,MAAM,YAAA,GAAe,CAAC,EAAA,KAA4B,CAAC,CAAA,KAAwB;AACvE,IAAA,CAAA,EAAG,cAAA,IAAiB;AAEpB,IAAA,MAAM,EAAA,GAAK,MAAM,QAAA,EAAS;AAC1B,IAAA,MAAM,IAAA,GAAO,EAAA,CAAG,SAAA,IAAa,EAAC;AAC9B,IAAA,MAAM,UAAe,IAAA,CAAK,KAAA,CAAM,KAAK,SAAA,CAAU,IAAA,CAAK,aAAa,CAAC,CAAA;AAClE,IAAA,MAAA,CAAO,IAAA,CAAK,IAAI,CAAA,CAAE,OAAA,CAAQ,CAAC,CAAA,KAAM;AAC7B,MAAA,MAAM,EAAA,GAAK,IAAA,CAAK,CAAC,CAAA,EAAG,OAAA;AAAS,MAAA,IAAI,CAAC,EAAA,EAAI;AAEtC,MAAA,MAAM,KAAA,GAAQ,UAAU,CAAC,CAAA;AACzB,MAAa,SAAA,CAAU,OAAA,EAAS,KAAK;AACrC,MAAA,MAAM,IAAI,EAAA,CAAG,KAAA;AACb,MAAA,MAAM,IAAA,GAAO,SAAA,CAAU,OAAA,EAAS,KAAA,EAAO,CAAC,CAAA;AACxC,MAAA,MAAA,CAAO,MAAA,CAAO,SAAS,IAAI,CAAA;AAAA,IAC/B,CAAC,CAAA;AACD,IAAA,EAAA,CAAG,OAAO,CAAA;AAAA,EACd,CAAA;AAEA,EAAA,OAAO,EAAE,QAAA,EAAU,QAAA,EAAU,YAAA,EAAc,WAAW,KAAA,EAAM;AAChE;AAEO,SAAS,YAAA,GAAkB;AAC9B,EAAA,MAAM,GAAA,GAAM,KAAA,CAAM,UAAA,CAAW,GAAG,CAAA;AAChC,EAAA,IAAI,CAAC,GAAA,EAAK,MAAM,IAAI,MAAM,0CAA0C,CAAA;AACpE,EAAA,OAAO,GAAA;AACX","file":"index.js","sourcesContent":["// ------------------------------------------------------------\n// src/core/path.ts\n// ------------------------------------------------------------\nimport type { PathLike, PathSeg } from './types';\n\nconst DANGEROUS_KEYS = new Set(['__proto__', 'prototype', 'constructor']);\n\nfunction assertSafeKey(k: string) {\n    if (DANGEROUS_KEYS.has(k)) throw new Error(`Unsafe key: ${k}`);\n}\n\nexport function parsePath(input: PathLike): PathSeg[] {\n    if (Array.isArray(input)) return Array.from(input as ReadonlyArray<PathSeg>);\n    const s = String(input);\n    if (!s) return [];\n    const out: PathSeg[] = [];\n    let i = 0;\n    const N = s.length;\n    while (i < N) {\n        // read identifier\n        let id = '';\n        while (i < N) {\n            const ch = s[i];\n            if (ch === '.' || ch === '[') break;\n            id += ch; i++;\n        }\n        if (id) {\n            assertSafeKey(id);\n            out.push(id);\n        }\n        if (i >= N) break;\n        const ch = s[i];\n        if (ch === '.') { i++; continue; }\n        if (ch === '[') {\n            // only numeric indices supported in MVP\n            i++; // skip [\n            let num = '';\n            while (i < N && s[i] !== ']') { num += s[i++]; }\n            if (i >= N) throw new Error('Unclosed bracket');\n            i++; // skip ]\n            if (!/^\\d+$/.test(num)) throw new Error(`Invalid index: ${num}`);\n            const idx = Number(num);\n            if (idx < 0 || !Number.isInteger(idx)) throw new Error(`Invalid index: ${num}`);\n            out.push(idx);\n            if (i < N && s[i] === '.') i++;\n        }\n    }\n    return out;\n}\n\nexport function getAtPath<T = any>(obj: any, path: PathLike): T | undefined {\n    const parts = parsePath(path);\n    let cur = obj;\n    for (const p of parts) {\n        if (cur == null) return undefined;\n        cur = cur[p as any];\n    }\n    return cur as T;\n}\n\nexport function setAtPath<T extends object = any>(obj: any, path: PathLike, value: any): T {\n    const parts = parsePath(path);\n    if (parts.length === 0) return value as T;\n    const rootIsArray = Array.isArray(obj);\n    const root: any = rootIsArray ? obj.slice() : { ...(obj ?? {}) };\n    let cur: any = root;\n    for (let i = 0; i < parts.length; i++) {\n        const seg = parts[i];\n        const isLast = i === parts.length - 1;\n        if (typeof seg === 'number') {\n            const next = cur[seg];\n            if (isLast) {\n                cur[seg] = value;\n            } else {\n                const nxtSeg = parts[i + 1];\n                const container = Array.isArray(next) || typeof nxtSeg === 'number' ? (Array.isArray(next) ? next.slice() : []) : ({ ...(next ?? {}) });\n                cur[seg] = container;\n                cur = container;\n            }\n        } else {\n            assertSafeKey(seg);\n            const next = cur[seg];\n            if (isLast) {\n                cur[seg] = value;\n            } else {\n                const nxtSeg = parts[i + 1];\n                const container = Array.isArray(next) || typeof nxtSeg === 'number' ? (Array.isArray(next) ? next.slice() : []) : ({ ...(next ?? {}) });\n                cur[seg] = container;\n                cur = container;\n            }\n        }\n    }\n    return root;\n}\n\n","// ------------------------------------------------------------\n// src/core/store.ts\n// ------------------------------------------------------------\nimport { createStore } from 'zustand/vanilla';\nimport { subscribeWithSelector } from 'zustand/middleware';\nimport type { FormStoreApi, FormStoreState, FormState } from './types';\n\nexport type Batcher = ReturnType<typeof createBatcher>;\n\nexport function createBatcher(cfg: { max?: number; useTransition?: boolean } = {}) {\n    const max = cfg.max ?? 1000;\n    const useTrans = !!cfg.useTransition;\n    let q: Record<string, any> = {};\n    let order: string[] = [];\n    let scheduled = false;\n    const schedule = (run: () => void) => {\n        if (scheduled) return; scheduled = true;\n        queueMicrotask(() => {\n            scheduled = false;\n            if (useTrans && typeof (globalThis as any).startTransition === 'function') {\n                (globalThis as any).startTransition(run);\n            } else run();\n        });\n    };\n    return {\n        push(key: string, payload: any, flush: (k: string, p: any) => void) {\n            if (!(key in q)) order.push(key);\n            q[key] = payload;                 // merge: keep last per key\n            if (order.length > max) order.shift(); // drop oldest key to cap\n            schedule(() => {\n                const keys = order; order = [];\n                const payloads = q; q = {};\n                for (const k of keys) flush(k, payloads[k]);\n            });\n        }\n    };\n}\n\nexport function createFormStore<T>(name: string, initial: T, devtools: boolean): FormStoreApi<T> {\n    const base: FormStoreState<T> = {\n        name: name || 'rzf',\n        __initial: initial,\n        formState: { dirtyFields: {}, touchedFields: {}, errors: {} },\n        resolverEpoch: 0,\n    };\n\n    const withMw = (creator: any) => (\n        (process.env.NODE_ENV !== 'production' && devtools)\n            ? (require('zustand/middleware').devtools as any)(subscribeWithSelector(creator), { name })\n            : subscribeWithSelector(creator)\n    );\n\n    // Create vanilla store (no React dependency here)\n    const storeImpl = createStore<FormStoreState<T>>(withMw(() => base));\n\n    return {\n        getState: storeImpl.getState,\n        setState: (updater, _replace, action) => {\n            const next = updater(storeImpl.getState());\n            // vanilla setState signature: (partial, replace?)\n            storeImpl.setState(next as any, true);\n            if ((storeImpl as any).setState.length >= 3 && action) {\n                // devtools action label\n                (storeImpl as any).setState(next as any, true, action);\n            }\n        },\n        subscribe: (fn) => storeImpl.subscribe(fn),\n    };\n}","// ------------------------------------------------------------\n// src/core/hooks.tsx\n// ------------------------------------------------------------\nimport React from 'react';\nimport type { DirtyMap, FormErrors, FormState, FormStoreApi, UseFormOptions, RegisterOptions } from './types';\nimport { getAtPath, setAtPath, parsePath } from './path';\nimport { createFormStore, createBatcher } from './store';\n\nconst Ctx = React.createContext<FormStoreApi<any> | null>(null);\n\nexport function useForm<T>(opts: UseFormOptions<T>) {\n    const name = opts.name || 'rzf';\n    const storeRef = React.useRef<FormStoreApi<T>>();\n    if (!storeRef.current) {\n        storeRef.current = createFormStore<T>(name, opts.defaultValues, !!opts.devtools);\n    }\n    const store = storeRef.current!;\n\n    // local UI mirrors (optional; consumers may read store directly)\n    const [formState, setFormState] = React.useState<FormState>(store.getState().formState);\n\n    React.useEffect(() => {\n        const unsub = store.subscribe((s) => setFormState(s.formState));\n        return () => unsub();\n    }, [store]);\n\n    // --- resolver (async-safe with epoch)\n    const runResolverAndApply = React.useCallback(async (values: T) => {\n        if (!opts.resolver) return;\n        const token = ++store.getState().resolverEpoch;\n        try {\n            const result = await opts.resolver(values);\n            if (token !== store.getState().resolverEpoch) return; // outdated\n            const errors = result?.errors ?? {};\n            store.setState((s) => ({ ...s, formState: { ...s.formState, errors } }), false, { type: `${name} resolver:ok` });\n        } catch (err: any) {\n            if (token !== store.getState().resolverEpoch) return;\n            const errors: FormErrors = { _root: String(err?.message ?? err) };\n            store.setState((s) => ({ ...s, formState: { ...s.formState, errors } }), false, { type: `${name} resolver:err` });\n        }\n    }, [name, opts.resolver, store]);\n\n    // --- Provider\n    const Provider: React.FC<React.PropsWithChildren<{}>> = React.useCallback(({ children }) => {\n        return <Ctx.Provider value={store}> {children} </Ctx.Provider>;\n    }, [store]);\n\n    // --- register (supports uncontrolled)\n    function register(path: string, ropts: RegisterOptions = {}) {\n        const parts = parsePath(path);\n        const def = getAtPath(opts.defaultValues as any, parts as any);\n        if (ropts.uncontrolled) {\n            return {\n                name: path,\n                defaultValue: def as any,\n                ref: (el: HTMLInputElement | null) => {\n                    if (!el) return;\n                    const st = store.getState();\n                    const refs = st.__domRefs ?? (st.__domRefs = {});\n                    refs[path] = { current: el };\n                },\n                onChange: (e: React.ChangeEvent<HTMLInputElement>) => {\n                    const now = e.currentTarget.value;\n                    const isDirty = String(now) !== String(def ?? '');\n                    store.setState((s) => ({ ...s, formState: { ...s.formState, dirtyFields: { ...s.formState.dirtyFields, [path]: isDirty } } }), false, { type: `${name} field:dirty` });\n                },\n                onBlur: () => {\n                    store.setState((s) => ({ ...s, formState: { ...s.formState, touchedFields: { ...s.formState.touchedFields, [path]: true } } }), false, { type: `${name} field:touched` });\n                }\n            } as const;\n        }\n        // controlled (minimal): bind through store.value (not fully featured; MVP)\n        return {\n            name: path,\n            value: getAtPath((store.getState() as any).value ?? (opts.defaultValues as any), parts as any) ?? '',\n            onChange: (e: React.ChangeEvent<HTMLInputElement>) => {\n                const v = e.currentTarget.value;\n                let nextValLocal: any;\n                store.setState((s) => {\n                    const prev = (s as any).value ?? (opts.defaultValues as any);\n                    const nextVal = setAtPath(prev, parts as any, v);\n                    nextValLocal = nextVal; // capture for resolver\n                    const dirty: DirtyMap = {\n                        ...s.formState.dirtyFields,\n                        [path]: String(v) !== String(def ?? ''),\n                    };\n                    return { ...s, value: nextVal, formState: { ...s.formState, dirtyFields: dirty } } as any;\n                }, false, { type: `${name} field:set` });\n\n                // Schedule resolver in a microtask to avoid reentrancy and to play nice with tests\n                const enqueue = (cb: () => void) =>\n                    typeof queueMicrotask === 'function'\n                        ? queueMicrotask(cb)\n                        : Promise.resolve().then(cb);\n                enqueue(() => runResolverAndApply(nextValLocal as T));\n            },\n            onBlur: () => {\n                store.setState((s) => ({ ...s, formState: { ...s.formState, touchedFields: { ...s.formState.touchedFields, [path]: true } } }), false, { type: `${name} field:touched` });\n            }\n        } as const;\n    }\n\n    // --- handleSubmit (collects uncontrolled via refs; controlled via state)\n    const handleSubmit = (fn: (values: T) => void) => (e?: React.FormEvent) => {\n        e?.preventDefault?.();\n        // Uncontrolled: read from DOM\n        const st = store.getState();\n        const refs = st.__domRefs ?? {};\n        const fromDom: any = JSON.parse(JSON.stringify(opts.defaultValues));\n        Object.keys(refs).forEach((p) => {\n            const el = refs[p]?.current; if (!el) return;\n            // best-effort: write string value\n            const parts = parsePath(p);\n            const prev = getAtPath(fromDom, parts);\n            const v = el.value;\n            const next = setAtPath(fromDom, parts, v);\n            Object.assign(fromDom, next);\n        });\n        fn(fromDom);\n    };\n\n    return { Provider, register, handleSubmit, formState, store } as const;\n}\n\nexport function useFormStore<T>() {\n    const ctx = React.useContext(Ctx);\n    if (!ctx) throw new Error('useFormStore must be used under Provider');\n    return ctx as FormStoreApi<T>;\n}\n\n\n\n"]}